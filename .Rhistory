if (any(varmu == 0)) {stop("0s in V(mu)")}
mu.eta.val <- mu.eta(eta)
if (any(is.na(mu.eta.val[good])))   stop("NAs in d(mu)/d(eta)")
good <- (weights > 0) & (mu.eta.val != 0)
if (all(!good)) {
conv <- FALSE
warning("no observations informative at iteration ",iter)
break
}
Xold = X
ngoodobs <- as.integer(nobs - sum(abs(mu.eta.val) <= eps))
if (ngoodobs < min(0.2 * nobs, 20)) {
conv = TRUE
break
}
#  z <- (eta - offset)[good] + (y - mu)[good]/mu.eta.val[good]        #GLM
ytilde <- (eta - offset)[good] + (y - mu)[good]/mu.eta.val[good]
#        ytilde <- eta[good] + (y - mu)[good]/mu.eta.val[good] #ANTES
w <- sqrt((weights[good] * mu.eta.val[good]^2)/variance(mu)[good])
X[, nvars + intercept] = rep(mean(ytilde - apply(X[good,1:nvars, drop = FALSE], 1, sum)), nobs)
if (control$trace)
cat("#------------------------------------------------\n")
if (control$trace)
cat("Iter:", iter, ngoodobs, "/", nobs, "alpha:",
X[1, nvars + intercept], "Dev:", dev, "\n")
for (i in 1:nvars) {
off = apply(X[good, -i, drop = FALSE], 1, sum)
z = ytilde - off
if (control$trace)    print(summary(ytilde))
offdf = sum(eqrank[-i])
xfunc = xlist[[namesx[i]]][good]
mgood<- metric[[namesx[i]]]
h<-par.np[[namesx[i]]]$h
if (control$trace)   cat("Range h:", range(h), length(h), "\n")
Ker=ifelse(is.character(par.np[[namesx[i]]]$Ker),get(par.np[[namesx[i]]]$Ker),par.np[[namesx[i]]]$Ker)
type.S=par.np[[namesx[i]]]$type.S
parS=par.np[[namesx[i]]]$par.S
parS$w=w
if (is.function(type.S)) ty<-deparse(substitute(type.S))
else ty<-type.S
res = fregre.np.cv(xfunc, z, h = h, type.CV = "dev.S", Ker=Ker,
type.S=ty,par.S=parS,metric = mgood, par.metric=par.metric[[namesx[i]]], par.CV = list(obs = y[good],
family = family, off = off, offdf = offdf,W = diag(w)))
if (control$trace)
cat("Var:",namesx[[i]]," h.opt:", res$h.opt," df:",res$df,"\n")
print(length(res$residuals))
print(res$df.residual)
eqrank[namesx[i]] <- length(res$residuals) - res$df.residual
X[good,namesx[i]] <- res$fitted.values
result[[namesx[i]]] <- res
}
X[, nvars + intercept] = rep(mean(ytilde - apply(X[good,
1:nvars, drop = FALSE], 1, sum)), nobs)
#        eta <- apply(X, 1, sum)
eta <- rowSums(X)
mu <- linkinv(eta <- eta + offset)
#        mu <- linkinv(eta)
mu.eta.val <- mu.eta(eta)
good <- (weights > 0) & (mu.eta.val != 0)
ngoodobs <- as.integer(nobs - sum(mu.eta.val <= eps))
dev <- sum(dev.resids(y,mu,weights))
if (control$trace)   {
par(mfrow = c(1, nvars + 1))
if (length(table(y) > 10)) {colores = 1}
else { colores = y + 1 }
plot(eta, mu, col = colores)
points(eta, y, col = colores, pch = 2)
for (i in 1:nvars) {
plot(X[, i], eta, col = colores, ylab = "Linear Predictor",
xlab = paste("f(", namesx[i], ")", sep = ""),
main = paste(namesx[i], "EqPar:", round(eqrank[i],1)))
if (length(table(y)) == 2) {
abline(h = 0)
abline(v = 0)
}
}
}
#        cambio = apply((X - Xold)^2, 2, mean)
cambio = colMeans((X - Xold)^2)
if (control$trace) {
cat("Shift Iter:", iter, "EqRank:", sum(eqrank),
ngoodobs, "/", nobs, "\n")
print(cambio)
}
if (any(cambio[1:nvars] > control$epsilon)) {conv <- FALSE}
else{conv <- TRUE;break  }
if (sum(eqrank) > ngoodobs) {conv <- TRUE;break  }
if (!(valideta(eta) && validmu(mu))) {
warning("step size truncated: out of bounds", call. = FALSE)
ii <- 1
while (!(valideta(eta) && validmu(mu))) {
if (ii > control$maxit)
stop("inner loop 2; cannot correct step size",
call. = FALSE)
ii <- ii + 1
X <- (X + Xold)/2
#                eta <- apply(X, 1, sum)
eta <- rowSums(X)
mu <- linkinv(eta)
}
boundary <- TRUE
dev <- sum(dev.resids(y, mu, weights))
if (control$trace)  cat("Step halved: new deviance =", dev, "\n")
}
if (all(!good)) {
conv <- FALSE
warning("no observations informative at iteration ",iter)
break
}
if (control$trace)
cat("Deviance =", dev, "Iterations -", iter, "\n")
if (abs(dev - devold)/(0.1 + abs(dev)) < control$epsilon |
dev < control$epsilon) {
conv <- TRUE
break
}
}
if (!conv)
warning("kgam.fit: algorithm did not converge", call. = FALSE)
if (family$family == "binomial") {
if (any(mu > 1 - eps) || any(mu < eps))
warning("kgam.fit: fitted probabilities numerically 0 or 1 occurred",
call. = FALSE)
}
if (family$family == "poisson") {
if (any(mu < eps))
warning("kgam.fit: fitted rates numerically 0 occurred",
call. = FALSE)
}
residuals <- (y - mu)#/     (eta) ##### ok??
nr <- min(sum(good), nvars)
names(residuals) <- ynames
names(mu) <- ynames
names(eta) <- ynames
wt <- rep.int(0,nobs)
wt[good] <- w^2
names(wt) <- ynames
names(weights) <- ynames
names(y) <- ynames
wtdmu <- if (intercept)   sum(weights * y)/sum(weights)
else linkinv(0)
nulldev <- sum(dev.resids(y, wtdmu, weights))
n.ok <- nobs - sum(weights == 0)
nulldf <- n.ok - as.integer(intercept)
aic.model <- aic(y, nobs, mu, weights, dev) + 2 * sum(eqrank)
names(result)<-namesx
H<-kgam.H(result,control$inverse)
sr2<-sum(residuals^2)/(nobs - sum(eqrank))
#    if (family$family=="binomial" & !is.factor(y)) y<-factor(y)
res <- list(result = result, residuals = residuals, fitted.values = mu,
effects = X, alpha = mean(X[, nvars + intercept]), family = family,
linear.predictors = eta, deviance = dev, aic = aic.model,
null.deviance = nulldev, iter = iter, weights = wt, eqrank = eqrank,
prior.weights = weights, y = y0, converged = conv,H=H,sr2=sr2)
class(res) <- "fregre.gkam"
res
}
res2=fregre.gkam(f2,family=binomial(),data=xlist,
par.np=par.NP,control=list("trace"=T))
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(devtools)
library(fda.usc)
fregre.gkam
?fregre.gkam
library(fda.usc)
?fregre.gkam
data(tecator)
ab=tecator$absorp.fdata[1:100]
ab2=fdata.deriv(ab,2)
yfat=tecator$y[1:100,"Fat"]
# Example 1: # Changing the argument par.np and family
yfat.cat=ifelse(yfat<15,0,1)
xlist=list("df"=data.frame(yfat.cat),"ab"=ab,"ab2"=ab2)
f2<-yfat.cat~ab+ab2
par.NP<-list("ab"=list(Ker=AKer.norm,type.S="S.NW"),
"ab2"=list(Ker=AKer.norm,type.S="S.NW"))
res2=fregre.gkam(f2,family=binomial(),data=xlist,
par.np=par.NP)
res2
?fregre.np
data(tecator)
absorp=tecator$absorp.fdata
ind=1:129
x=absorp[ind,]
y=tecator$y$Fat[ind]
res.np=fregre.np(x,y,Ker=AKer.epa)
summary(res.np)
res.np2=fregre.np(x,y,Ker=AKer.tri)
summary(res.np2)
res.np$df
res.np$df.residual
data(tecator)
absorp=tecator$absorp.fdata
ind=1:129
x=absorp[ind,]
y=tecator$y$Fat[ind]
res.np=fregre.np(x,y,Ker=AKer.epa)
summary(res.np)
res.np2=fregre.np(x,y,Ker=AKer.tri)
summary(res.np2)
library(fda.usc)
?fregre.np
## Not run:
data(tecator)
absorp=tecator$absorp.fdata
ind=1:129
x=absorp[ind,]
y=tecator$y$Fat[ind]
res.np=fregre.np(x,y,Ker=AKer.epa)
res.np$df
library(fda.usc)
?fregre.np
data(tecator)
absorp=tecator$absorp.fdata
ind=1:129
x=absorp[ind,]
y=tecator$y$Fat[ind]
res.np=fregre.np(x,y,Ker=AKer.epa)
summary(res.np)
res.np2=fregre.np(x,y,Ker=AKer.tri)
summary(res.np2)
library(fda.usc)
fregre.np
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(devtools)
# devtools::install_github("moviedo5/fda.usc",auth_user="moviedo5")
devtools::install_github("moviedo5/fda.usc")
642*1.21
620*750
620*1.21
707*1.21
library(fda.usc)
?fregre.np
data(tecator)
absorp=tecator$absorp.fdata
ind=1:129
x=absorp[ind,]
y=tecator$y$Fat[ind]
res.np=fregre.np(x,y,Ker=AKer.epa)
summary(res.np)
res.np$df
summary.basis.fdata=function(object, draw=TRUE, index=NULL) {
#object <- bb
cat("\n     - SUMMARY -\n")
le <- length(object$basis)
R <- numeric(le)
#print(R)
n <- nrow(object$fdataobj)
R2 <- matrix(NA,n,le)
colnames(R2)<-paste0(substr(object$type,1,3),"(1:",1:le,")")
rownames(R2)<-rownames(object$fdataobj)
Xcen <- fdata.cen(object$fdataobj)$Xcen
type=FALSE
cat("Type of basis:",object$type,"\nNum. of basis:",le,"\nRangeval:",object$basis$rangeval,"\n")
for (l in 1:le){
if (object$type =="pc" | object$type == "pls"){
type=TRUE
#xmean <- func.mean(object$fdataobj)
xmean <- object$mean
fdata.est <- basis2fdata(object$coefs[,1:l,drop=F],
object$basis[1:l])
} else{ fdata.est <- basis2fdata(object$coefs[,1:l,drop=F],
object$basis[1:l])
#R2[l] <- 1 - sum(norm.fdata(fdata.est-object$fdataobj)^2)/
#   sum(norm.fdata(fdata.cen(object$fdataobj)$Xcen)^2)
}
R[l] <- 1-sum(norm.fdata(fdata.est-object$fdataob)^2)/sum(norm.fdata(Xcen)^2)
R2[,l] <- 1 - norm.fdata(fdata.est-object$fdataobj)^2/norm.fdata(Xcen)^2
}
if (is.null(index)) {
ymin <- min(4,n);     index<- 1:ymin
}
txt <- paste(length(index),"curves (in grey) and their basis representation (in red) are plotted")
if (draw) {
# yl <- c(min(object$fdataobj,fdata.est),max(object$fdataobj,fdata.est))
yl <- c(min(object$fdataobj[index],fdata.est[index]),max(object$fdataobj[index],fdata.est[index]))
# mn <- expression( 1 - frac(paste( "||X - ",hat(X),"||"),paste( "||X - ",bar(X),"||")))
mn <-  expression( paste("X(t) vs ",hat(X),"(t)"))
plot(object$fdataobj[index],main=mn,col="grey",ylim=yl)
lines(fdata.est[index],lty=2,col=2)
}
#  En el texto pon 1- Sum(||---||^2)/Sum(||---||^2)
#  message(paste( "||X - ",expression(bar(X)),"||"))
cat("\nMeasure of fit: 1 - Sum||X - hat(X)||^2  / Sum||X - bar(X)||^2:\n")
names(R) <- paste0("basis(1:",1:le,")",sep="")
if (!type)    R <- R[le]
#print(expression( 1 - paste( "||X - ",hat(X),"|| / ||X - ",bar(X),"||")))
print(R)
if (draw) cat("\n",txt)
return(invisible(R2))
}
data(aemet)
y1<- aemet$temp
base.pls <- fdata2pls(y1,aemet$df$latitude,5)
cc <- fdata2basis(y1,base.pls,method="inprod")
library(fda.usc)
data(aemet)
y1<- aemet$temp
base.pls <- fdata2pls(y1,aemet$df$latitude,5)
cc <- fdata2basis(y1,base.pls,method="inprod")
summary(cc)
y1<- aemet$temp
base.pls <- fdata2pc(y1,5)
summary(base.pls)
cc <- fdata2basis(y1,base.pls,method="inprod")
summary(cc)
#' @title Compute fucntional coefficients from functional data represented in a base of functions
#'
#' @description Compute fucntional coefficients from functional data (\code{\link{fdata}} class object)
#' represented in a basis (fixed of data-driven basis).
#'
#' @aliases fdata2basis
#' @param fdataobj \code{\link{fdata}} class object.
#' @param basis  	a functional basis object defining the basis
#' @param method character string, if it is "grid" the fdata object is evaluated in the grid (\code{argvals} of fdata),
#'  if it is "inprod" the basis representation of functional data is computed by inner product
#'  (\code{\link{inprod.fdata}(fdataobj,basis)}).
#' @return \code{fdata2bais} function return:
#' \itemize{
#' \item {coef}{a matrix or two-dimensional array of coefficients.}
#' \item {basis}{basis of \code{\link{fdata}} class evaluated in the same grid of \code{fdataobj}. }
#' }
#' @author Manuel Febrero-Bande, Manuel Oviedo de la Fuente  \email{manuel.oviedo@@usc.es}
#' @seealso  Inverse function: \code{\link{gridfdata}}.
#' Alternative method: \code{\link{fdata2pc}}, \code{\link{fdata2pls}}.
# @references
#' @keywords multivariate
#' @examples
#' \dontrun{
#' T <- 71
#' S <- 51
#' tj <- round(seq(0,1,len=T),3)
#' si <- round(seq(0,1,len=S),3)
#' beta1 <- outer(si,tj,function(si,tj){exp(-5*abs((tj-si)/5))})
#' nbasis.s =7
#' nbasis.t=11
#' base.s <- create.fourier.basis(c(0,1),nbasis=nbasis.s)
#' base.t <- create.fourier.basis(c(0,1),nbasis=nbasis.t)
#' y1 <- fdata(rbind(log(1+tj),1-5*(tj-0.5)^2),argvals=tj,rangeval=c(0,1))
#' aa <- fdata2basis(y1,base.t,method="inprod")
#' summary(aa)
#' plot(gridfdata(aa$coefs,aa$basis))
#' lines(y1,lwd=2,col=c(3,4),lty=2)
#' base.pc <- create.pc.basis(y1,1:2,norm=F)
#' bb <- fdata2basis(y1,base.pc,method="inprod")
#' bb <- fdata2basis(y1,base.pc)
#' lines(gridfdata(bb$coefs,bb$basis))
#' lines(base.pc[[1]])
#'
#' }
#' @export
fdata2basis <- function(fdataobj, basis, method=c("grid","inprod")){
xmean <- NULL
if (is.basis(basis)){
bb=fdata(t(eval.basis(fdataobj$argvals,basis)),
argvals=fdataobj$argvals,rangeval=fdataobj$rangeval)
} else if (class(basis) %in% c("fdata")){
bb=basis
xmean <- func.mean(fdataobj)
} else {
bb=  basis$basis
xmean <- basis$mean
}
if (method[1]=="grid"){
A=t(fdataobj$data)
B=t(bb$data)
coefs=t(Minverse(t(B)%*%B)%*%t(B)%*%A)
} else {
A=t(inprod.fdata(fdataobj,bb))
B=inprod.fdata(bb)
coefs=t(solve(B)%*%A)
}
if (!is.null(basis$type)) type <- basis$type
#if (!is.null(bb$names$main)) type <- bb$names$main
out <- list(coefs=coefs,basis=bb,
fdataobj=fdataobj,
type=type,
mean = xmean
)
class(out) <- "basis.fdata"
return(out)
}
bb <- fdata2basis(y1,base.pc)
lines(bb$basis)
#wrapper of gridfdata
basis2fdata<-function (coef, fdataobj, mu)
{
return(gridfdata(coef, fdataobj, mu) )
}
# Devolver la matriz entera R2 para todas las curvas en un summary
# parece excesivamente prolijo. Como texto habría que devolver un R2
# conjunto  con el tamaño global de la base:
#   1-sum(norm.fdata(.,.)^2)/sum(norm.fdata(Xcen)^2).
# La función debe devolver la matriz R2 como invisible por si
# se quiere usar posteriormente pero devolver el mismo objeto
# que entra no tiene mucha utilidad. Respecto al texto que se
# incluye al principio (solo la llamada de la función) no sé
# si sería mejor poner un texto con el object$type, la longitud
# y alguna info sobre los argvals y el rangeval.
summary.basis.fdata=function(object, draw=TRUE, index=NULL) {
#object <- bb
cat("\n     - SUMMARY -\n")
le <- length(object$basis)
R <- numeric(le)
#print(R)
n <- nrow(object$fdataobj)
R2 <- matrix(NA,n,le)
colnames(R2)<-paste0(substr(object$type,1,3),"(1:",1:le,")")
rownames(R2)<-rownames(object$fdataobj)
Xcen <- fdata.cen(object$fdataobj)$Xcen
type=FALSE
cat("Type of basis:",object$type,"\nNum. of basis:",le,"\nRangeval:",object$basis$rangeval,"\n")
for (l in 1:le){
if (object$type =="pc" | object$type == "pls"){
type=TRUE
#xmean <- func.mean(object$fdataobj)
xmean <- object$mean
fdata.est <- basis2fdata(object$coefs[,1:l,drop=F],
object$basis[1:l])
} else{ fdata.est <- basis2fdata(object$coefs[,1:l,drop=F],
object$basis[1:l])
#R2[l] <- 1 - sum(norm.fdata(fdata.est-object$fdataobj)^2)/
#   sum(norm.fdata(fdata.cen(object$fdataobj)$Xcen)^2)
}
R[l] <- 1-sum(norm.fdata(fdata.est-object$fdataob)^2)/sum(norm.fdata(Xcen)^2)
R2[,l] <- 1 - norm.fdata(fdata.est-object$fdataobj)^2/norm.fdata(Xcen)^2
}
if (is.null(index)) {
ymin <- min(4,n);     index<- 1:ymin
}
txt <- paste(length(index),"curves (in grey) and their basis representation (in red) are plotted")
if (draw) {
# yl <- c(min(object$fdataobj,fdata.est),max(object$fdataobj,fdata.est))
yl <- c(min(object$fdataobj[index],fdata.est[index]),max(object$fdataobj[index],fdata.est[index]))
# mn <- expression( 1 - frac(paste( "||X - ",hat(X),"||"),paste( "||X - ",bar(X),"||")))
mn <-  expression( paste("X(t) vs ",hat(X),"(t)"))
plot(object$fdataobj[index],main=mn,col="grey",ylim=yl)
lines(fdata.est[index],lty=2,col=2)
}
#  En el texto pon 1- Sum(||---||^2)/Sum(||---||^2)
#  message(paste( "||X - ",expression(bar(X)),"||"))
cat("\nMeasure of fit: 1 - Sum||X - hat(X)||^2  / Sum||X - bar(X)||^2:\n")
names(R) <- paste0("basis(1:",1:le,")",sep="")
if (!type)    R <- R[le]
#print(expression( 1 - paste( "||X - ",hat(X),"|| / ||X - ",bar(X),"||")))
print(R)
if (draw) cat("\n",txt)
return(invisible(R2))
}
library(fda.usc)
data(aemet)
y1<- aemet$temp
base.pls <- fdata2pls(y1,aemet$df$latitude,5)
cc <- fdata2basis(y1,base.pls,method="inprod")
summary(cc)
y1<- aemet$temp
base.pls <- fdata2pc(y1,5)
summary(base.pls)
cc <- fdata2basis(y1,base.pls,method="inprod")
plot(y1,lwd=2,col=c(3,4),lty=2)
base.pc <- create.pc.basis(y1,1:2,norm=F)
bb <- fdata2basis(y1,base.pc,method="inprod")
lines(gridfdata(bb$coefs,bb$basis))
bb <- fdata2basis(y1,base.pc)
# no ayuda por el momento
fdata2basis2d=function(fdata2d,basis.s,basis.t){
n=dim(fdata2d$data)[1]
if (is.basis(basis.s)) {
basis.s=fdata(t(eval.basis(fdata2d$argvals[[1]],basis.s)),
argvals=fdata2d$argvals[[1]],rangeval=fdata2d$rangeval[[1]])
}
if (is.basis(basis.t)) {
basis.t=fdata(t(eval.basis(fdata2d$argvals[[2]],basis.t)),
argvals=fdata2d$argvals[[2]],rangeval=fdata2d$rangeval[[2]])
}
n.s=nrow(basis.s)
n.t=nrow(basis.t)
eta=basis.s$data;theta=basis.t$data
Jeta=tcrossprod(eta);Jtheta=tcrossprod(theta)
AA=Minverse(Jeta)%*%eta
BB=t(theta)%*% Minverse(Jtheta)
B=array(NA,dim=c(n,n.s,n.t))
#B=solve(Jeta)%*%eta%*%fdata2d%*%t(theta)%*%solve(Jtheta)
for (i in 1:n){B[i,,]=AA%*%fdata2d$data[i,,]%*%BB}
return(list(coefs=B,b.s=basis.s,b.t=basis.t))
}
library(devtools)
devtools::install_github("moviedo5/fda.usc")
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(devtools)
# devtools::install_github("moviedo5/fda.usc",auth_user="moviedo5")
