lw.l <- as.numeric(coeft - 1.96*sdt)
p.v <- x$co13$p.value[t13, ]
TAB13 <- cbind(Estimate = as.numeric(coeft), St.Err = as.numeric(sdt), LW.L = lw.l, UP.L = up.l, p.value = p.v)
rownames(TAB13) <- names(coeft)
colnames(TAB13) <- c("Estimate", "St.Err", "LW.L", "UP.L", "P.value")
cat("\nCoefficients 13:\n")
print(TAB13)
t23 <- length(x$co23$time)
coeft <- x$co13$coefficients[t23, ]
sdt <- x$co13$SD[t23, ]
zval <- coeft/sdt
up.l <- as.numeric(coeft + 1.96*sdt)
lw.l <- as.numeric(coeft - 1.96*sdt)
p.v <- x$co23$p.value[t23, ]
NMO <- x$n.misobs
TAB23 <- cbind(Estimate = as.numeric(coeft), St.Err = as.numeric(sdt), LW.L = lw.l, UP.L = up.l, p.value = p.v)
rownames(TAB23) <- names(coeft)
colnames(TAB23) <- c("Estimate", "St.Err", "LW.L", "UP.L", "P.value")
cat("\nCoefficients 23:\n")
print(TAB23)
cat("\n\n")
print(paste(NMO, "observations deleted due to missingness from 'data'"))
}
else{
t <- length(x$co$time)
coeft <- x$co$coefficients[t, ]
sdt <- x$co$SD[t, ]
zval <- coeft/sdt
up.l <- as.numeric(coeft + 1.96*sdt)
lw.l <- as.numeric(coeft - 1.96*sdt)
p.v <- x$co$p.value[t, ]
NMO <- x$n.misobs
TAB <- cbind(Estimate = as.numeric(coeft), St.Err = as.numeric(sdt), LW.L = lw.l, UP.L = up.l, p.value = p.v)
rownames(TAB) <- names(coeft)
colnames(TAB) <- c("Estimate", "St.Err", "LW.L", "UP.L", "P.value")
cat("Call:\n")
print(x$call)
cat("\nTransition:\n")
print(x$transition)
cat("\n(s,t):\n")
print(c(x$s, x$t))
cat("\nCoefficients:\n")
print(TAB)
cat("\n\n")
print(paste(NMO, "observations deleted due to missingness from 'data'"))
}
}
summary.TPreg <- function(object,...){
cat("Call:\n")
print(object$call)
if (object$transition == "all") {
nlist <- 4
nam <- c("11", "12", "13", "23")
cat("Transitions:\n")
print(nam)
}
else {
nam <- object$transition
nlist <- 1
}
cat("(s,t):\n")
print(c(object$s, object$t))
for (i in 1:nlist){
ilist <- object[[i]]
cat("\n",paste("Transition ", nam[i], sep=""), " :\n")
cat("\n     Coefficients:\n")
print(cbind(time = ilist$time, ilist$coefficients))
cat("\n     Standard Errors:\n")
print(cbind(time = ilist$time, ilist$SD))
cat("\n     Lower limit:\n")
print(cbind(time = ilist$time, ilist$LWL))
cat("\n     Upper limit:\n")
print(cbind(time = ilist$time, ilist$UPL))
cat("\n     p.value:\n")
print(data.frame(cbind(time = ilist$time, ilist$p.value)))
cat("\n\n")
}
W.n.misobs <- paste( object$n.misobs, "observation(s) deleted due to missingness from 'data'")
print(W.n.misobs)
}
plot.TPreg <- function(x, covar, rug=TRUE,  main, ylab, xlab, Ylim,  ...)
{
if (missing(xlab)) xlab="time"
if (x$transition=="all") {
nfun <- 4
nam.p <- c("11", "12", "13", "23")
}
else {
nfun <- 1
nam.p <- x$transition
}
if (missing(covar)) covar <- colnames(x[[1]]$coefficients)[-1]
if (!is.character(covar)) stop(" 'covar' must be a single character string referring the name of a covariable")
ncovar <- length(covar)
n.plots <- nfun*ncovar
mar0=c(4,3.9,4,3.9)
if (n.plots == 0)
stop("No terms to plot - nothing for plot.TPreg() to do.")
ppp <- n.plots
c <- r <- trunc(sqrt(ppp))
if (c < 1)       r <- c <- 1
if (c * r < ppp) c <- c + 1
if (c * r < ppp) r <- r + 1
oldpar <- par(mfrow = c(r, c), mar = mar0)
mis.lab <- missing(ylab)
mis.main <- missing(main)
mis.Ylim <- missing(Ylim)
for (i.fun in 1:nfun){
for (i.covar in 1:ncovar){
if (mis.Ylim) {ylim = NULL
}
else {ylim = Ylim[[i.covar]]
}
col <- covar[i.covar]
time11 <- x[[i.fun]]$time
i.co <- x[[i.fun]]
co11 <- i.co$coeff
if (mis.lab) ylab <- paste("effect", "of", col)
if (mis.main) main <- paste("TP:", nam.p[i.fun] )
plot(time11, co11[ , col], type = "s", xlab = xlab, ylab = ylab, main = main, ylim = ylim, ...)
lines(time11, i.co$LWL[,col], type = "s", col = "lightseagreen")
lines(time11, i.co$UPL[,col], type = "s", col = "lightseagreen")
lines(time11, rep(0,length(time11)), col = "red", lty = 2)
if (rug) rug(as.numeric(time11 ), ...)
}
}
}
data(colon, package = "survival")
colonTPreg <- data.frame(id=colon$id[seq(1,length(rownames(colon)),2)], Zt=pmin(colon$time[colon$etype==1],colon$time[colon$etype==2]), Tt=colon$time[colon$etype==2],delta1=pmax(colon$status[colon$etype==1], colon$status[colon$etype==2]), delta=colon$status[colon$etype==2], Nodes=colon$nodes[seq(1,length(rownames(colon)),2)], Age=colon$age[seq(1, length(rownames(colon)),2)],treatment=colon$rx[seq(1, length(rownames(colon)),2)])
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores
proctime()[3]
proc.time()[3]
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
summary(co11)
b
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
ncores = 1
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
ncores = 1
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
ncores = 7
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
ncores = 7
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 7
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
bÃ§
b
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
ncores = 8
b<-numeric(10)
for (i in 1:b){
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
}
mean(b);sd(b)
nr <- 10
b<-numeric(nr)
for (i in 1:nr){
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
}
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
nr <- 10
b<-numeric(nr)
for (i in 1:nr){
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
}
mean(b);sd(b)
stopCluster()
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
nr <- 10
b<-numeric(nr)
for (i in 1:nr){
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
}
mean(b);sd(b)
stopImplicitCluster()
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
nr <- 10
b<-numeric(nr)
for (i in 1:nr){
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
}
mean(b);sd(b)
?stopCluster
?doParallel
cl <- makePSOCKcluster(2)
registerDoParallel(cl)
m <- matrix(rnorm(9), 3, 3)
foreach(i=1:nrow(m), .combine=rbind)
stopCluster(cl)
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
nr <- 10
b<-numeric(nr)
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
?snow
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(devtools)
devtools::install_github("moviedo5/fda.usc")
library(devtools)
devtools::install_github("moviedo5/fda.usc")
# A naive implementation of the Nadaraya-Watson estimator
mNW <- function(x, X, Y, h, K = dnorm) {
# Arguments
# x: evaluation points
# X: vector (size n) with the predictors
# Y: vector (size n) with the response variable
# h: bandwidth
# K: kernel
# Matrix of size n x length(x)
Kx <- sapply(X, function(Xi) K((x - Xi) / h) / h)
# Weights
W <- Kx / rowSums(Kx) # Column recycling!
# Means at x ("drop" to drop the matrix attributes)
drop(W %*% Y)
}
library(fda.usc)
?S.NW
# A naive implementation of the Nadaraya-Watson estimator
mNW <- function(x, X, Y, h, K = dnorm) {
# Arguments
# x: evaluation points
# X: vector (size n) with the predictors
# Y: vector (size n) with the response variable
# h: bandwidth
# K: kernel
# Matrix of size n x length(x)
Kx <- sapply(X, function(Xi) K((x - Xi) / h) / h)
# Weights
W <- Kx / rowSums(Kx) # Column recycling!
# Means at x ("drop" to drop the matrix attributes)
drop(W %*% Y)
}
# A naive implementation of the Nadaraya-Watson estimator
mNW <- function(x, X, Y, h, K = dnorm) {
# Arguments
# x: evaluation points
# X: vector (size n) with the predictors
# Y: vector (size n) with the response variable
# h: bandwidth
# K: kernel
# Matrix of size n x length(x)
Kx <- sapply(X, function(Xi) K((x - Xi) / h) / h)
# Weights
W <- Kx / rowSums(Kx) # Column recycling!
# Means at x ("drop" to drop the matrix attributes)
drop(W %*% Y)
}
tt=1:101
Ker.norm
S=S.LLR(tt,h=5,Ker=Ker.norm)
S[1:3,1:3]
S3=S.NW(tt,h=10,Ker=Ker.norm)
S3=S.NW(tt,h=4,Ker=Ker.norm)
S3=S.NW(tt,h=4,Ker=Ker.norm)
S=S.LLR(tt,h=5,Ker=Ker.norm)
S[1:3,1:3]
S3=S.NW(tt,h=4,Ker=Ker.norm)
S3[1:3,1:3]
# Generate some data to test the implementation
set.seed(12345)
n <- 100
eps <- rnorm(n, sd = 2)
m <- function(x) x^2 * cos(x)
# m <- function(x) x - x^2 # Other possible regression function, works
# equally well
X <- rnorm(n, sd = 2)
Y <- m(X) + eps
xGrid <- seq(-10, 10, l = 500)
# Bandwidth
h <- 0.5
# Plot data
plot(X, Y)
rug(X, side = 1); rug(Y, side = 2)
source('C:/Users/moviedo/github/fda.usc/R/S.np.R', echo=TRUE)
source('C:/Users/moviedo/github/fda.usc/R/S.np.R', echo=TRUE)
source('C:/Users/moviedo/github/fda.usc/R/S.np.R')
mNW <- function(x, X, Y, h, K = dnorm) {
# Arguments
# x: evaluation points
# X: vector (size n) with the predictors
# Y: vector (size n) with the response variable
# h: bandwidth
# K: kernel
# Matrix of size n x length(x)
Kx <- sapply(X, function(Xi) K((x - Xi) / h) / h)
# Weights
W <- Kx / rowSums(Kx) # Column recycling!
# Means at x ("drop" to drop the matrix attributes)
drop(W %*% Y)
}
set.seed(12345)
n <- 100
eps <- rnorm(n, sd = 2)
m <- function(x) x^2 * cos(x)
# m <- function(x) x - x^2 # Other possible regression function, works
# equally well
X <- rnorm(n, sd = 2)
Y <- m(X) + eps
xGrid <- seq(-10, 10, l = 500)
# Bandwidth
h <- 0.5
# Plot data
plot(X, Y)
rug(X, side = 1); rug(Y, side = 2)
lines(xGrid, m(xGrid), col = 1)
m(xGrid)
lines(xGrid, mNW(x = xGrid, X = X, Y = Y, h = h), col = 2)
legend("top", legend = c("True regression", "Nadaraya-Watson"),
lwd = 2, col = 1:2)
S3=S.NW(xGrid,h=.5,Ker=Ker.norm)
S3%*%Y
S3
dim(S3)
Y
X
S3=S.NW(X,h=.5,Ker=Ker.norm)
dim(S3)
S3%*%Y
lines(S3%*%Y,col=4)
lines(X,S3%*%Y,col=4)
S3%*%Y
X
lines(X,as.numeric(S3%*%Y),col=4)
plot(X, Y)
rug(X, side = 1); rug(Y, side = 2)
lines(xGrid, m(xGrid), col = 1)
lines(xGrid, mNW(x = xGrid, X = X, Y = Y, h = h), col = 2)
lines(X,as.numeric(S3%*%Y),col=4)
X
# Plot data
plot(X, Y)
rug(X, side = 1); rug(Y, side = 2)
lines(xGrid, m(xGrid), col = 1)
lines(xGrid, mNW(x = xGrid, X = X, Y = Y, h = h), col = 2)
points(X,as.numeric(S3%*%Y),col=4)
#' @rdname S.np
#' @export
S.NW2<-function (tt, h=NULL, Ker = Ker.norm,w=NULL,cv=FALSE) {
if (is.matrix(tt)) {
if (ncol(tt)!=nrow(tt)) {
if (ncol(tt)==1) {
tt=as.vector(tt)
tt=outer(tt,tt, "-")} # tt=abs(outer(tt,tt, "-"))}
#else stop("Error: incorrect arguments passed")
}}
else if (is.vector(tt))    tt=outer(tt,tt, "-") #tt=abs(outer(tt,tt, "-"))
else stop("Error: incorrect arguments passed")
if (is.null(h)) {
h=quantile(tt,probs=0.15,na.rm=TRUE)
while(h==0) {
h=quantile(tt,probs=pp,na.rm=TRUE)
pp<-pp+.05
}
}
if (cv)  diag(tt)=Inf
tt2<-data.matrix(sweep(tt,1,h,FUN="/"))
k<-Ker(tt2)
#print(any(is.na(tt2)))
if (is.null(w)) w<-rep(1,len=ncol(tt))
k1 <- sweep(k,2,w,FUN="*")
#  S =k1/apply(k1,1,sum)
rw<-rowSums(k1,na.rm = TRUE)
rw[rw==0]<-1e-28
S =k1/rw
return(S)
}
S4=S.NW2(X,h=.5,Ker=Ker.norm)
points(X,as.numeric(S4%*%Y),col=3)
S.NW
S.NW2
