if (missing(covar)) covar <- colnames(x[[1]]$coefficients)[-1]
if (!is.character(covar)) stop(" 'covar' must be a single character string referring the name of a covariable")
ncovar <- length(covar)
n.plots <- nfun*ncovar
mar0=c(4,3.9,4,3.9)
if (n.plots == 0)
stop("No terms to plot - nothing for plot.TPreg() to do.")
ppp <- n.plots
c <- r <- trunc(sqrt(ppp))
if (c < 1)       r <- c <- 1
if (c * r < ppp) c <- c + 1
if (c * r < ppp) r <- r + 1
oldpar <- par(mfrow = c(r, c), mar = mar0)
mis.lab <- missing(ylab)
mis.main <- missing(main)
mis.Ylim <- missing(Ylim)
for (i.fun in 1:nfun){
for (i.covar in 1:ncovar){
if (mis.Ylim) {ylim = NULL
}
else {ylim = Ylim[[i.covar]]
}
col <- covar[i.covar]
time11 <- x[[i.fun]]$time
i.co <- x[[i.fun]]
co11 <- i.co$coeff
if (mis.lab) ylab <- paste("effect", "of", col)
if (mis.main) main <- paste("TP:", nam.p[i.fun] )
plot(time11, co11[ , col], type = "s", xlab = xlab, ylab = ylab, main = main, ylim = ylim, ...)
lines(time11, i.co$LWL[,col], type = "s", col = "lightseagreen")
lines(time11, i.co$UPL[,col], type = "s", col = "lightseagreen")
lines(time11, rep(0,length(time11)), col = "red", lty = 2)
if (rug) rug(as.numeric(time11 ), ...)
}
}
}
data(colon, package = "survival")
colonTPreg <- data.frame(id=colon$id[seq(1,length(rownames(colon)),2)], Zt=pmin(colon$time[colon$etype==1],colon$time[colon$etype==2]), Tt=colon$time[colon$etype==2],delta1=pmax(colon$status[colon$etype==1], colon$status[colon$etype==2]), delta=colon$status[colon$etype==2], Nodes=colon$nodes[seq(1,length(rownames(colon)),2)], Age=colon$age[seq(1, length(rownames(colon)),2)],treatment=colon$rx[seq(1, length(rownames(colon)),2)])
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores
proctime()[3]
proc.time()[3]
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
summary(co11)
b
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
ncores = 1
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
ncores = 1
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 99, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
ncores = 7
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
ncores = 7
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 7
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
bÃ§
b
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b = proc.time()[3]-a
b
ncores = 8
b<-numeric(10)
for (i in 1:b){
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
}
mean(b);sd(b)
nr <- 10
b<-numeric(nr)
for (i in 1:nr){
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
}
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
nr <- 10
b<-numeric(nr)
for (i in 1:nr){
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
}
mean(b);sd(b)
stopCluster()
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
nr <- 10
b<-numeric(nr)
for (i in 1:nr){
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
}
mean(b);sd(b)
stopImplicitCluster()
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
nr <- 10
b<-numeric(nr)
for (i in 1:nr){
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
}
mean(b);sd(b)
?stopCluster
?doParallel
cl <- makePSOCKcluster(2)
registerDoParallel(cl)
m <- matrix(rnorm(9), 3, 3)
foreach(i=1:nrow(m), .combine=rbind)
stopCluster(cl)
data(colonTPreg)
ncores <- detectCores(all.tests = FALSE, logical = TRUE)
ncores = 8
nr <- 10
b<-numeric(nr)
a <- proc.time()[3]
co11 <- TPreg( ~ Age + Nodes + treatment, colonTPreg, link = "logit", s = 20, R = 199, t = 200,
trans = "11",  ncores = ncores )
co11
b[i] = proc.time()[3]-a
?snow
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(devtools)
devtools::install_github("moviedo5/fda.usc")
library(devtools)
devtools::install_github("moviedo5/fda.usc")
# A naive implementation of the Nadaraya-Watson estimator
mNW <- function(x, X, Y, h, K = dnorm) {
# Arguments
# x: evaluation points
# X: vector (size n) with the predictors
# Y: vector (size n) with the response variable
# h: bandwidth
# K: kernel
# Matrix of size n x length(x)
Kx <- sapply(X, function(Xi) K((x - Xi) / h) / h)
# Weights
W <- Kx / rowSums(Kx) # Column recycling!
# Means at x ("drop" to drop the matrix attributes)
drop(W %*% Y)
}
library(fda.usc)
?S.NW
# A naive implementation of the Nadaraya-Watson estimator
mNW <- function(x, X, Y, h, K = dnorm) {
# Arguments
# x: evaluation points
# X: vector (size n) with the predictors
# Y: vector (size n) with the response variable
# h: bandwidth
# K: kernel
# Matrix of size n x length(x)
Kx <- sapply(X, function(Xi) K((x - Xi) / h) / h)
# Weights
W <- Kx / rowSums(Kx) # Column recycling!
# Means at x ("drop" to drop the matrix attributes)
drop(W %*% Y)
}
# A naive implementation of the Nadaraya-Watson estimator
mNW <- function(x, X, Y, h, K = dnorm) {
# Arguments
# x: evaluation points
# X: vector (size n) with the predictors
# Y: vector (size n) with the response variable
# h: bandwidth
# K: kernel
# Matrix of size n x length(x)
Kx <- sapply(X, function(Xi) K((x - Xi) / h) / h)
# Weights
W <- Kx / rowSums(Kx) # Column recycling!
# Means at x ("drop" to drop the matrix attributes)
drop(W %*% Y)
}
tt=1:101
Ker.norm
S=S.LLR(tt,h=5,Ker=Ker.norm)
S[1:3,1:3]
S3=S.NW(tt,h=10,Ker=Ker.norm)
S3=S.NW(tt,h=4,Ker=Ker.norm)
S3=S.NW(tt,h=4,Ker=Ker.norm)
S=S.LLR(tt,h=5,Ker=Ker.norm)
S[1:3,1:3]
S3=S.NW(tt,h=4,Ker=Ker.norm)
S3[1:3,1:3]
# Generate some data to test the implementation
set.seed(12345)
n <- 100
eps <- rnorm(n, sd = 2)
m <- function(x) x^2 * cos(x)
# m <- function(x) x - x^2 # Other possible regression function, works
# equally well
X <- rnorm(n, sd = 2)
Y <- m(X) + eps
xGrid <- seq(-10, 10, l = 500)
# Bandwidth
h <- 0.5
# Plot data
plot(X, Y)
rug(X, side = 1); rug(Y, side = 2)
source('C:/Users/moviedo/github/fda.usc/R/S.np.R', echo=TRUE)
source('C:/Users/moviedo/github/fda.usc/R/S.np.R', echo=TRUE)
source('C:/Users/moviedo/github/fda.usc/R/S.np.R')
mNW <- function(x, X, Y, h, K = dnorm) {
# Arguments
# x: evaluation points
# X: vector (size n) with the predictors
# Y: vector (size n) with the response variable
# h: bandwidth
# K: kernel
# Matrix of size n x length(x)
Kx <- sapply(X, function(Xi) K((x - Xi) / h) / h)
# Weights
W <- Kx / rowSums(Kx) # Column recycling!
# Means at x ("drop" to drop the matrix attributes)
drop(W %*% Y)
}
set.seed(12345)
n <- 100
eps <- rnorm(n, sd = 2)
m <- function(x) x^2 * cos(x)
# m <- function(x) x - x^2 # Other possible regression function, works
# equally well
X <- rnorm(n, sd = 2)
Y <- m(X) + eps
xGrid <- seq(-10, 10, l = 500)
# Bandwidth
h <- 0.5
# Plot data
plot(X, Y)
rug(X, side = 1); rug(Y, side = 2)
lines(xGrid, m(xGrid), col = 1)
m(xGrid)
lines(xGrid, mNW(x = xGrid, X = X, Y = Y, h = h), col = 2)
legend("top", legend = c("True regression", "Nadaraya-Watson"),
lwd = 2, col = 1:2)
S3=S.NW(xGrid,h=.5,Ker=Ker.norm)
S3%*%Y
S3
dim(S3)
Y
X
S3=S.NW(X,h=.5,Ker=Ker.norm)
dim(S3)
S3%*%Y
lines(S3%*%Y,col=4)
lines(X,S3%*%Y,col=4)
S3%*%Y
X
lines(X,as.numeric(S3%*%Y),col=4)
plot(X, Y)
rug(X, side = 1); rug(Y, side = 2)
lines(xGrid, m(xGrid), col = 1)
lines(xGrid, mNW(x = xGrid, X = X, Y = Y, h = h), col = 2)
lines(X,as.numeric(S3%*%Y),col=4)
X
# Plot data
plot(X, Y)
rug(X, side = 1); rug(Y, side = 2)
lines(xGrid, m(xGrid), col = 1)
lines(xGrid, mNW(x = xGrid, X = X, Y = Y, h = h), col = 2)
points(X,as.numeric(S3%*%Y),col=4)
#' @rdname S.np
#' @export
S.NW2<-function (tt, h=NULL, Ker = Ker.norm,w=NULL,cv=FALSE) {
if (is.matrix(tt)) {
if (ncol(tt)!=nrow(tt)) {
if (ncol(tt)==1) {
tt=as.vector(tt)
tt=outer(tt,tt, "-")} # tt=abs(outer(tt,tt, "-"))}
#else stop("Error: incorrect arguments passed")
}}
else if (is.vector(tt))    tt=outer(tt,tt, "-") #tt=abs(outer(tt,tt, "-"))
else stop("Error: incorrect arguments passed")
if (is.null(h)) {
h=quantile(tt,probs=0.15,na.rm=TRUE)
while(h==0) {
h=quantile(tt,probs=pp,na.rm=TRUE)
pp<-pp+.05
}
}
if (cv)  diag(tt)=Inf
tt2<-data.matrix(sweep(tt,1,h,FUN="/"))
k<-Ker(tt2)
#print(any(is.na(tt2)))
if (is.null(w)) w<-rep(1,len=ncol(tt))
k1 <- sweep(k,2,w,FUN="*")
#  S =k1/apply(k1,1,sum)
rw<-rowSums(k1,na.rm = TRUE)
rw[rw==0]<-1e-28
S =k1/rw
return(S)
}
S4=S.NW2(X,h=.5,Ker=Ker.norm)
points(X,as.numeric(S4%*%Y),col=3)
S.NW
S.NW2
data(tecator)
absorp=tecator$absorp.fdata
ind=1:129
x=absorp[ind,]
y=tecator$y$Fat[ind]
Ker=AKer.tri
res.np=fregre.np.cv(x,y,Ker=Ker)
library(fda.usc)
#' data(tecator)
#' absorp=tecator$absorp.fdata
#' ind=1:129
#' x=absorp[ind,]
#' y=tecator$y$Fat[ind]
#' Ker=AKer.tri
#' res.np=fregre.np.cv(x,y,Ker=Ker)
data(tecator)
absorp=tecator$absorp.fdata
ind=1:129
x=absorp[ind,]
y=tecator$y$Fat[ind]
Ker=AKer.tri
res.np=fregre.np.cv(x,y,Ker=Ker)
res.np=fregre.np.cv(x,y)
summary(res.np)
res.np2=fregre.np.cv(x,y,type.CV=GCV.S,criteria="Shibata")
summary(res.np2)
## Example with other semimetrics (not run)
res.pca1=fregre.np.cv(x,y,Ker=Ker,metric=semimetric.pca,q=1)
summary(res.pca1)
res.deriv=fregre.np.cv(x,y,Ker=Ker,metric=semimetric.deriv)
summary(res.deriv)
x.d2=fdata.deriv(x,nderiv=1,method="fmm",class.out='fdata')
res.deriv2=fregre.np.cv(x.d2,y,Ker=Ker)
summary(res.deriv2)
x.d3=fdata.deriv(x,nderiv=1,method="bspline",class.out='fdata')
res.deriv3=fregre.np.cv(x.d3,y,Ker=Ker)
summary(res.deriv3)
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(devtools)
devtools::install_github("moviedo5/fda.usc",auth_user="moviedo5")
library(devtools)
devtools::install_github("moviedo5/fda.usc",auth_user="moviedo5")
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(devtools)
devtools::install_github("moviedo5/fda.usc")
library(fda.usc)
?fregre.np.cv
library(fda.usc)
?fregre.np.cv
data(tecator)
absorp=tecator$absorp.fdata
ind=1:129
x=absorp[ind,]
y=tecator$y$Fat[ind]
Ker=AKer.tri
res.np=fregre.np.cv(x,y,Ker=Ker)
Ker
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
library(devtools)
devtools::install_github("moviedo5/fda.usc",auth_user="moviedo5")
2
library(roxygen2)
setwd("C:/Users/moviedo/github/fda.usc/")
getwd()
pkgbuild::compile_dll()
roxygenize()
devtools::document()
3
library(devtools)
devtools::install_github("moviedo5/fda.usc",auth_user="moviedo5")
library(devtools)
devtools::install_github("moviedo5/fda.usc",auth_user="moviedo5")
library(devtools)
devtools::install_github("moviedo5/fda.usc",auth_user="moviedo5")
library(devtools)
devtools::install_github("moviedo5/fda.usc",auth_user="moviedo5")
